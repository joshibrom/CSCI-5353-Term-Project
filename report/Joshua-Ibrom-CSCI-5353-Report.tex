\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\usepackage[newfloat]{minted}
\usepackage{caption}

\setminted{fontsize=\footnotesize, breaklines}

\newenvironment{code}{\captionsetup{type=listing}}{}
\SetupFloatingEnvironment{listing}{name=Listing}

\begin{document}

\title{A Comparative Analysis of Multilingual Approaches to Erroneous C Code}

\author{
\IEEEauthorblockN{Joshua Ibrom}
\IEEEauthorblockA{\textit{Dept. of CEMS} \\
\textit{Texas A\&M University - San Antonio}\\
San Antonio, US \\
jibro01@jaguar.tamu.edu}
}

\maketitle

\begin{abstract}
Historically there has been a great deal of code written in the C programming
language. Despite its popularity, C and code written in it are widely
considered ``unsafe'' as there may be many runtime errors and undefined
behaviors contained within C codebases. As such, more modern languages like
Zig (which theoretically has its share of memory-related safety errors) and
Rust are considered as alternative languages to migrate / translate legacy C
codebases into. This paper explores how these languages might be a safer
alternative, especially regarding runtime errors and undefined behaviors, by
evaluating C code with KLEE and by performing manual static analysis of LLVM
Intermediate Representation (IR) code in an effort to find what protections
and restrictions might exist in a more modern language (such as exhaustive
switching and overflow detection) to ensure that applications carry with them
a ``safer'' binary. Conclusions are drawn on the depth by which a given C
codebase may be translated to one in another language since some features of
C do not carry, thus prohibiting a one-to-one translation of the codebase.
\end{abstract}

\begin{IEEEkeywords}
C code safety, LLVM IR analysis, programming language translation
\end{IEEEkeywords}

\section{Background}
The fields of computer science and computer programming have advanced greatly
since the introduction of the C programming language, a ``general purpose
programming language featuring economy of expression, modern control flow, and
data structure capabilities [with] a rich set of operators and data types''
\cite{ritchie1978c}, in 1972 when it was first developed
\cite{tyagi2014tribute}. Since C's development, many applications have been
written using the language, leading to there being the potential of many code
samples that lend to some erroneous or undefined behavior due to C's inherent
design wherein a developer must consider the correct data type for some value
and manage the memory from the allocation to freeing of that data.

In the wake of unsafe programs written by C programmers across the spectrum of
skill levels and familiarities with the language and its idempotent design
patterns, programmers have created more modern successor languages. Of these
languages are Zig (first published in 2017), a ``general-purpose programming
language and toolchain for maintaining robust, optimal, and reusable software''
\cite{zigGithubRepo}, and Rust (first published in 2010), a systems programming
language focusing on memory safety and performance \cite{bugden2022rust}. Rust,
however, is better-labeled as being some successor and competitor of C++,
another systems / general-purpose programming language which itself is derived
from the syntax of C \cite{bugden2022rust}.

\subsection{C as it Relates to Zig and Rust}
Being that Rust is not a direct ancestor of C, we might ask why this language
should be compared to both C and Zig, which itself is a competitor of C that
boasts support for integration with \texttt{libc} but does not depend on it
\cite{zig2025overview}? To answer this, we might consider some fundamental issue
with C code: integer overflows. If we consider the example C code shown in
Listing \ref{lst:c-integer-overflow}, we find that this code contains an
integer overflow where some operation, in this case being addition, results in a
value greater than the containing data type may store, in this case being an
\texttt{unsigned char} which may store values 0-255, inclusive. As such, the
output of the code shown in Listing \ref{lst:c-integer-overflow} would be 69.

\begin{code}
    \medskip
    \inputminted{c}{../code-examples/c/integer-overflow.c}
    \captionof{listing}{Integer overflow example in C.}
    \label{lst:c-integer-overflow}
    \medskip
\end{code}

Zig and Rust both have built-in methods of detecting and reporting this behavior,
usually through the running thread panicking on the overflow. Zig, being more akin
to C, therefore makes sense to include in the scope of this paper as a ``safer''
alternative to C (albeit with its own memory-related issues). Since safety is more
of a priority in modern application development, I felt that including a ``safe''
language like Rust in this paper would also be well-suited for the comparisons made
herein.

\subsection{Research Questions}
\begin{enumerate}
    \item How effective are compilers of more modern languages at identifying and
        addressing potential pitfalls, especially as they relate to runtime errors?
    \item How effective is KLEE at in identifying and addressing these same
        pitfalls?
    \item How effective is translation to a safer and more modern language at
        remedying potential pitfalls and runtime errors?
\end{enumerate}


\section{Related Work}
Symbolic execution, being some method that ``symbolize[s] the input data of
[a] program [...by using] symbol variables instead of real variables to
explore and parse a program'' \cite{zhang2020survey}. Tools such as KLEE
\cite{cadar2021klee} have been developed to facilitate this process,
enabling programmers to find potential bugs and dependencies for exploring
most paths to sometimes include those that contain some non-standard runtime
behavior.

Symbolic execution may be applied in conjugation with exploring some compiled
representation of a given sample of code through other static analysis means.
SKINK \cite{cassez2017skink} is one such tool which may be used in this case,
with the tool relying on C/C++ \texttt{assert} statements to determine if the
given code satisfies the specification described by the \texttt{assert}s. The
authors of this tool do note the limitations of this approach, with many
being around special cases where the LLVM IR has been optimized; however,
through targeting the LLVM IR we find that their tool is theoretically
usable for analyzing code written in any language that compiles to some LLVM
IR (which in this case could include Zig and Rust) \cite{cassez2017skink}.

Given that there must be some benchmark by which a tool's performance may
be evaluated, we may consider the Juliet Test Suite \cite{boland2012juliet}
which contains code samples that demonstrate various common weakness
enumerations (CWEs) in C/C++ and Java. Being that there are language
limitations, one such approach of expanding this dataset to target other
languages (where possible) is to use artificial intelligence and large
language models to translate some sample of code into another language, such
as from C to Rust as is being conducted by DARPA \cite{emre2021translating}.
This approach is not perfect and requires additional verification of
translated code, however \cite{fulton2025how}.


\section{Proposed Solution}
For this paper, I propose the following method of answering the guiding research
questions:
\begin{enumerate}
    \item Gather various C code samples which demonstrate errors in C, focusing
        primarily on runtime errors.
    \item Evaluate these C samples with a symbolic execution engine, in this case
        being KLEE \cite{cadar2021klee}.
    \item Use \texttt{zig translate} to translate the samples from C code to Zig
        code and evaluate the code and it's LLVM intermediate representation (IR).
    \item Perform a manual best-effort translation of the samples to idempotent
        Zig and Rust samples, comparing their code and their LLVM IRs.
\end{enumerate}

With this approach the effectiveness of modern compilers at identifying and
addressing potential pitfalls (such as integer overflows) should be evaluated, as
should the effectiveness of KLEE in doing the same. Within this process we may then
determine if language translation is more effective and in what way this translation
may be more effective---translations may not be one-to-one with the original C code
samples and the degree to which there may be variation for the sake of safety must
be considered.


\section{Dataset}
The dataset used is a collection of self-written C samples which focus primarily on
integer overflows, nonexhaustive switching, and divisions by zero. All source samples
are listed within the artifacts of this paper under the directory
``\texttt{code-examples/c/}''. Each C file may be described as follows:
\begin{itemize}
    \item \textit{integer-overflow.c}: Demonstrates an integer overflow where two
        \texttt{unsigned char} values are added with their result being stored in an
        \texttt{unsigned char}.
    \item \textit{advanced\_integer\_overflow.c}: Demonstrates the aforementioned
        integer overflow but includes additional branching logic which will return a
        boolean value of if an overflow had occurred.
    \item \textit{nonexhaustive-switching.c}: Demonstrates a situation in which an
        \texttt{enum} is switched upon without all paths being covered.
    \item \textit{div-by-zero.c}: Demonstrates a division by 0.
\end{itemize}


\section{Results and Analysis}
Performing the experiment as proposed yielded interesting results. As a baseline, the
\textit{integer-overflow.c} code sample was first analyzed, followed by the
\textit{advanced\_integer\_overflow.c} code sample since it was deemed necessary to
add some branching logic so that the performance of KLEE could be better-evaluated.
Following that, \textit{nonexhaustive-switching.c} was analyzed and then
\textit{div-by-zero.c}.


\subsection{Integer Overflows}
Considering the code sample observed in Listing \ref{lst:c-integer-overflow}, we find
that there will always be some integer overflow that occurs. When compiled and ran, the
program does perform this overflow. When attempting to compile and run the translated
Zig version, handwritten Zig version, and handwritten Rust versions, we find that these
all panic on the overflow (assuming that none were compiled with any level of
optimization).

\begin{code}
    \medskip
    \hrulefill\\
    C:
    \inputminted[firstline=6,lastline=19]{llvm}{../code-examples/c/integer-overflow.ll}
    \hrulefill\\
    Zig:
    \inputminted[firstline=148697,lastline=148718]{llvm}{../code-examples/zig/integer_overflow.ll}
    \hrulefill\\
    Rust:
    \inputminted[firstline=129,lastline=145]{llvm}{../code-examples/rust/integer_overflow.ll}
    \captionof{listing}{LLVM IRs of various \texttt{add} function implementations.}
    \label{lst:llvm-integer-overflow}
    \medskip
\end{code}

Should there have been some level of optimization applied, we may then find
that the safety checks are removed in both cases of using Zig and Rust
(assuming Zig's \textit{ReleaseFast} optimization level and at least a level
of 1 for Rust). In other cases, we may find that in the compilation the
resulting value of the integer overflow is pre-computed such that there is
no call to the \texttt{add} function and the computed value is stored
directly in the LLVM IR.

Considering the LLVM IR code shown in Listing \ref{lst:llvm-integer-overflow}, we may
then observe the safety checks that Zig and Rust perform to detect and report that some
integer overflow has occurred. While not shown due to length, the LLVM IR of the translated
Zig code should be noted to contain the same safety checks.

If we run KLEE against this code, marking both inputs of the \texttt{add} function as symbolic,
we find that KLEE correctly reports there is one execution path involving this function. If we
then implement branching such that we return from the program a boolean value of if there was
some overflow (shown in Listing \ref{lst:c-branched-overflow}), we find that in this case KLEE
does find that there exists another path---a path which without integer overflows could not be
realized.

\begin{code}
    \medskip
    \inputminted{c}{../code-examples/c-klee/advanced_integer_overflow.c}
    \captionof{listing}{A C integer overflow example with branching depending on if an
    overflow occurs.}
    \label{lst:c-branched-overflow}
    \medskip
\end{code}

Using KLEE, we observe the two paths from symbolic values $a$ and $b$ as follows:
\begin{enumerate}
    \item $a\mapsto0,\ b\mapsto1$: There is no overflow and we return 0;
    \item $a\mapsto255,\ b\mapsto1$: There is some overflow and we return 1.
\end{enumerate}
In this way, we may begin to realize the power of symbolic execution in finding various
logical paths and how they might be reached---a useful tool when attempting to find and
remedy bugs and errors in C code.


\subsection{Nonexhaustive Switching}
\begin{code}
    \medskip
    \inputminted{c}{../code-examples/c/nonexhaustive-switching.c}
    \captionof{listing}{C code that demonstrates nonexhaustive switching.}
    \label{lst:c-nonex-switching}
    \medskip
\end{code}

If we consider the C code shown in Listing \ref{lst:c-nonex-switching} we may observe that there
is a path which is not explored for case \texttt{BISH\_BOSH}. While this does generally get
reported as a warning when attempting to compile the C program, that warning cannot be relied on.
Within both Zig and Rust we find that this behavior is not allowed as both languages require
their \texttt{switch} / \texttt{match} constructs (for Zig and Rust, respectively) to be
exhaustive, meaning that all paths must be covered in some manner for a Zig or Rust program to
compile. For this reason, I find it interesting when considering the translated C to Zig code
shown in Listing \ref{lst:zig-nonex-switching}.

\begin{code}
    \medskip
    \inputminted[firstline=64,lastline=78]{zig}{../code-examples/zig-translations/nonexhaustive-switching.zig}
    \captionof{listing}{Translated Zig code for Listing \ref{lst:c-nonex-switching}.}
    \label{lst:zig-nonex-switching}
    \medskip
\end{code}

As may be seen in Listing \ref{lst:zig-nonex-switching}, the unhandled path is covered by Zig's
\texttt{else} clause. While this does make the Zig code compileable, this then means that there
is once more not a one-to-one translation of the C to Zig code and that should there have been
multiple unhandled paths those would all fall through to the \texttt{else} clause. This action
may ensure that 0 is guaranteed to be returned from the function in the event of some unhandled
path, but this also means that should the developer have not known that paths were not covered
there may never be knowledge of such since no warning or error would be reported to the
developer.

Considering the KLEE evaluation of the C code with the input value to \texttt{nonexhaustive}
being made symbolic, KLEE does find this unhandled input to the path, realizing that any other
integer value $i\notin\{FOO,\ BAR,\ BIZ,\ BAZ\}$ may be considered as an input to this function
and would result in some erroneous behavior.


\subsection{Division by Zero}
Another common bug in C programs which may be detected at compile time but could also propagate
as a runtime-only error is a division by zero. When considering this, we find that for some C
program containing an explicit division by zero we may still compile the program. In contrast,
Zig and Rust both detect this behavior during compilation and will throw some compilation error
to the developer. As such, we find that we cannot test Zig and Rust implementation where the
compiler is able to determine that some division by zero will always occur. Methods might exist
to circumnavigate this, such as parsing the string \texttt{"0"} to an integer, but this I feel
goes beyond the scope of what I would expect a compiler to compute at compile time irregardless
of the level of optimization being applied while compiling. As such, no further exploration of
this issue will be performed.


\section{Conclusion and Future Work}
In evaluating the results of this experiment, we find that the KLEE symbolic
execution tool is relatively effective in finding various paths in given C
code samples, even when those paths rely on some non-standard behavior such
as an integer overflow. Additionally, we observe the means by which we may
determine that languages such as Zig and Rust are intrinsically safer due to
their safety checks that they perform, such as panicking on some overflow and
requiring that their switch constructs be exhaustive in branch coverage. This
enhanced safety does come at the cost of translations into these languages not
being one-to-one. Arguably, undefined and erroneous behavior should not be
relied on for code to run as intended. Hence, we find that translation into a
safer language like Rust or Zig, even with Zig's manual memory management
model (though Zig can detect and report leaks), is a valuable strategy which
can enhance application safety.

Further research may include conducting the same method of analysis against
the Juliet Test Suite. Here, we shall find that there will be a challenge in
determining the method by which C code should be translated into Rust and
idempotent Zig code (meaning that \texttt{zig translate} is not used to
generate the Zig code) and in determining the level of accuracy in a given
translation being one-to-one. Additionally, this method may be applied to
any other language which compiles to LLVM IR and may also include any other
static analysis tool as the inclusion of more languages and tooling should
only be a net benefit in ensuring the accuracy of static analysis and the
safety of a programming language.


\bibliographystyle{IEEEtran}
\bibliography{report/sources}
\end{document}