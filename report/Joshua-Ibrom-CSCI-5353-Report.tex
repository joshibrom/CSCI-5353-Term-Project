\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\usepackage[newfloat]{minted}
\usepackage{caption}

\setminted{fontsize=\footnotesize, breaklines}

\newenvironment{code}{\captionsetup{type=listing}}{}
\SetupFloatingEnvironment{listing}{name=Listing}

\begin{document}

\title{A Comparative Analysis of Multilingual Approaches to Erroneous C Code}

\author{
\IEEEauthorblockN{Joshua Ibrom}
\IEEEauthorblockA{\textit{Dept. of CEMS} \\
\textit{Texas A\&M University - San Antonio}\\
San Antonio, US \\
jibro01@jaguar.tamu.edu}
}

\maketitle

\begin{abstract}
foo bar.
\end{abstract}

\begin{IEEEkeywords}
programming language translation, ai safety
\end{IEEEkeywords}

\section{Background}
The fields of computer science and computer programming have advanced greatly
since the introduction of the C programming language, a ``general purpose
programming language featuring economy of expression, modern control flow, and
data structure capabilities [with] a rich set of operators and data types''
\cite{ritchie1978c}, in 1972 when it was first developed
\cite{tyagi2014tribute}. Since C's development, many applications have been
written using the language, leading to there being the potential of many code
samples that lend to some erroneous or undefined behavior due to C's inherent
design wherein a developer must consider the correct data type for some value
and manage the memory from the allocation to freeing of that data.

In the wake of unsafe programs written by C programmers across the spectrum of
skill levels and familiarities with the language and its idempotent design
patterns, programmers have created more modern successor languages. Of these
languages are Zig (first published in 2017), a ``general-purpose programming
language and toolchain for maintaining robust, optimal, and reusable software''
\cite{zigGithubRepo}, and Rust (first published in 2010), a systems programming
language focusing on memory safety and performance \cite{bugden2022rust}. Rust,
however, is better-labeled as being some successor and competitor of C++,
another systems / general-purpose programming language which itself is derived
from the syntax of C \cite{bugden2022rust}.

\subsection{C as it Relates to Zig and Rust}
Being that Rust is not a direct ancestor of C, we might ask why this language
should be compared to both C and Zig, which itself is a competitor of C that
boasts support for integration with \texttt{libc} but does not depend on it
\cite{zig2025overview}? To answer this, we might consider some fundamental issue
with C code: integer overflows. If we consider the example C code shown in
Listing \ref{lst:c-integer-overflow}, we find that this code contains an
integer overflow where some operation, in this case being addition, results in a
value greater than the containing data type may store, in this case being an
\texttt{unsigned char} which may store values 0-255, inclusive. As such, the
output of the code shown in Listing \ref{lst:c-integer-overflow} would be 69.

\begin{code}
    \medskip
    \inputminted{c}{../code-examples/c/integer-overflow.c}
    \captionof{listing}{Integer overflow example in C.}
    \label{lst:c-integer-overflow}
    \medskip
\end{code}

Zig and Rust both have built-in methods of detecting and reporting this behavior,
usually through the running thread panicking on the overflow. Zig, being more akin
to C, therefore makes sense to include in the scope of this paper as a ``safer''
alternative to C (albeit with its own memory-related issues). Since safety is more
of a priority in modern application development, I felt that including a ``safe''
language like Rust in this paper would also be well-suited for the comparisons made
herein.

\subsection{Research Questions}
\begin{enumerate}
    \item How effective are compilers of more modern languages at identifying and
        addressing potential pitfalls, especially as they relate to runtime errors?
    \item How effective is KLEE at in identifying and addressing these same
        pitfalls?
    \item How effective is translation to a safer and more modern language at
        remedying potential pitfalls and runtime errors?
\end{enumerate}


\section{Related Work}


\section{Proposed Solution}
For this paper, I propose the following method of answering the guiding research
questions:
\begin{enumerate}
    \item Gather various C code samples which demonstrate errors in C, focusing
        primarily on runtime errors.
    \item Evaluate these C samples with a symbolic execution engine, in this case
        being KLEE \cite{cadar2021klee}.
    \item Use \texttt{zig translate} to translate the samples from C code to Zig
        code and evaluate the code and it's LLVM intermediate representation (IR).
    \item Perform a manual best-effort translation of the samples to idempotent
        Zig and Rust samples, comparing their code and their LLVM IRs.
\end{enumerate}

With this approach the effectiveness of modern compilers at identifying and
addressing potential pitfalls (such as integer overflows) should be evaluated, as
should the effectiveness of KLEE in doing the same. Within this process we may then
determine if language translation is more effective and in what way this translation
may be more effective---translations may not be one-to-one with the original C code
samples and the degree to which there may be variation for the sake of safety must
be considered.


\section{Dataset}
The dataset used is a collection of self-written C samples which focus primarily on
integer overflows, nonexhaustive switching, and divisions by zero. All source samples
are listed within the artifacts of this paper under the directory
``\texttt{code-examples/c/}''. Each C file may be described as follows:
\begin{itemize}
    \item \textit{integer-overflow.c}: Demonstrates an integer overflow where two
        \texttt{unsigned char} values are added with their result being stored in an
        \texttt{unsigned char}.
    \item \textit{advanced\_integer\_overflow.c}: Demonstrates the aforementioned
        integer overflow but includes additional branching logic which will return a
        boolean value of if an overflow had occurred.
    \item \textit{nonexhaustive-switching.c}: Demonstrates a situation in which an
        \texttt{enum} is switched upon without all paths being covered.
    \item \textit{div-by-zero.c}: Demonstrates a division by 0.
\end{itemize}


\section{Results and Analysis}
Performing the experiment as proposed yielded interesting results. As a baseline, the
\textit{integer-overflow.c} code sample was first analyzed, followed by the
\textit{advanced\_integer\_overflow.c} code sample since it was deemed necessary to
add some branching logic so that the performance of KLEE could be better-evaluated.
Following that, \textit{nonexhaustive-switching.c} was analyzed and then
\textit{div-by-zero.c}.


\subsection{Integer Overflows}
Considering the code sample observed in Listing \ref{lst:c-integer-overflow}, we find
that there will always be some integer overflow that occurs. When compiled and ran, the
program does perform this overflow. When attempting to compile and run the translated
Zig version, handwritten Zig version, and handwritten Rust versions, we find that these
all panic on the overflow (assuming that none were compiled with any level of
optimization).

\begin{code}
    \medskip
    \hrulefill\\
    C:
    \inputminted[firstline=6,lastline=19]{llvm}{../code-examples/c/integer-overflow.ll}
    \hrulefill\\
    Zig:
    \inputminted[firstline=148697,lastline=148718]{llvm}{../code-examples/zig/integer_overflow.ll}
    \hrulefill\\
    Rust:
    \inputminted[firstline=129,lastline=145]{llvm}{../code-examples/rust/integer_overflow.ll}
    \captionof{listing}{LLVM IRs of various \texttt{add} function implementations.}
    \label{lst:llvm-integer-overflow}
    \medskip
\end{code}

Considering the LLVM IR code shown in Listing \ref{lst:llvm-integer-overflow}, we may
then observe the safety checks that Zig and Rust perform to detect and report that some
integer overflow has occurred. While not shown due to length, the LLVM IR of the translated
Zig code should be noted to contain the same safety checks.

If we run KLEE against this code, marking both inputs of the \texttt{add} function as symbolic,
we find that KLEE correctly reports there is one execution path involving this function. If we
then implement branching such that we return from the program a boolean value of if there was
some overflow (shown in Listing \ref{lst:c-branched-overflow}), we find that in this case KLEE
does find that there exists another path---a path which without integer overflows could not be
realized.

\begin{code}
    \medskip
    \inputminted{c}{../code-examples/c-klee/advanced_integer_overflow.c}
    \captionof{listing}{A C integer overflow example with branching depending on if an
    overflow occurs.}
    \label{lst:c-branched-overflow}
    \medskip
\end{code}

Using KLEE, we observe the two paths from symbolic values $a$ and $b$ as follows:
\begin{enumerate}
    \item $a\mapsto0,\ b\mapsto1$: There is no overflow and we return 0;
    \item $a\mapsto255,\ b\mapsto1$: There is some overflow and we return 1.
\end{enumerate}
In this way, we may begin to realize the power of symbolic execution in finding various
logical paths and how they might be reached---a useful tool when attempting to find and
remedy bugs and errors in C code.


\subsection{Nonexhaustive Switching}
\begin{code}
    \medskip
    \inputminted{c}{../code-examples/c/nonexhaustive-switching.c}
    \captionof{listing}{C code that demonstrates nonexhaustive switching.}
    \label{lst:c-nonex-switching}
    \medskip
\end{code}

If we consider the C code shown in Listing \ref{lst:c-nonex-switching} we may observe that there
is a path which is not explored for case \texttt{BISH\_BOSH}. While this does generally get
reported as a warning when attempting to compile the C program, that warning cannot be relied on.
Within both Zig and Rust we find that this behavior is not allowed as both languages require
their \texttt{switch} / \texttt{match} constructs (for Zig and Rust, respectively) to be
exhaustive, meaning that all paths must be covered in some manner for a Zig or Rust program to
compile. For this reason, I find it interesting when considering the translated C to Zig code
shown in Listing \ref{lst:zig-nonex-switching}.

\begin{code}
    \medskip
    \inputminted[firstline=64,lastline=78]{zig}{../code-examples/zig-translations/nonexhaustive-switching.zig}
    \captionof{listing}{Translated Zig code for Listing \ref{lst:c-nonex-switching}.}
    \label{lst:zig-nonex-switching}
    \medskip
\end{code}

As may be seen in Listing \ref{lst:zig-nonex-switching}, the unhandled path is covered by Zig's
\texttt{else} clause. While this does make the Zig code compileable, this then means that there
is once more not a one-to-one translation of the C to Zig code and that should there have been
multiple unhandled paths those would all fall through to the \texttt{else} clause. This action
may ensure that 0 is guaranteed to be returned from the function in the event of some unhandled
path, but this also means that should the developer have not known that paths were not covered
there may never be knowledge of such since no warning or error would be reported to the
developer.

Considering the KLEE evaluation of the C code with the input value to \texttt{nonexhaustive}
being made symbolic, KLEE does find this unhandled input to the path, realizing that any other
integer value $i\notin\{FOO,\ BAR,\ BIZ,\ BAZ\}$ may be considered as an input to this function
and would result in some erroneous behavior.


\subsection{Division by Zero}
Another common bug in C programs which may be detected at compile time but could also propagate
as a runtime-only error is a division by zero. When considering this, we find that for some C
program containing an explicit division by zero we may still compile the program. In contrast,
Zig and Rust both detect this behavior during compilation and will throw some compilation error
to the developer. As such, we find that we cannot test Zig and Rust implementation where the
compiler is able to determine that some division by zero will always occur. Methods might exist
to circumnavigate this, such as parsing the string \texttt{"0"} to an integer, but this I feel
goes beyond the scope of what I would expect a compiler to compute at compile time irregardless
of the level of optimization being applied while compiling. As such, no further exploration of
this issue will be performed.


\section{Conclusion and Future Work}


\bibliographystyle{IEEEtran}
\bibliography{report/sources}
\end{document}